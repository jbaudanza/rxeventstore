RxEventStore
============

RxEventStore is a module for persisting and querying data using the
[Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) pattern and
[RxJs](https://github.com/ReactiveX/rxjs).

redis and postgresql are currently supported as data stores.

RxEventStore is designed to be used in concert with [RxRemote](https://github.com/jbaudanza/rxremote), which allows you to subscribe to observables remotely via a WebSocke, but either one can be used by itself.

## Installing with [NPM](https://www.npmjs.com/)

```bash`
$ npm install rxeventstore
```

## Introduction

In the Event Sourcing model, the canonical source of truth for your application resides entirely in an event log. You can have other data structures besides an event log, but they must all be generated by listening to events in the event log.

An event can be anything that user does that might mutate the state of your application. For example, a user posting a comment would create an event in the event log.

RxEventStore comes with drivers for using both redis and postgresql as an event log. There are two way to pull data out of the event store. The first uses an Observable that emits all the current events and any future events as they happen:

```js
var PgDatabase = require('rxeventstore/database/pg');

// Connect to an instance of postgres. The redis API is almost identical
var database = new PgDatabase("postgres://localhost/databasename");

// This returns an RxJs Observable
var source = database.observable('counter-events');

// The first parameter to insertEvent is a key that is used to group together events of similar semantics.
// The second parameter is the event value. This can be a number, string, or a JSON-serializable object.
database.insertEvent('counter-events', 1);
database.insertEvent('counter-events', 2);
database.insertEvent('counter-events', 3);

const subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });

// Notice that each invocation of next() includes a *batch* of events, instead of a single event.
// => Next: [1, 2, 3]

database.insertEvent('counter-events', 4);
// => Next: [4]

database.insertEvent('counter-events', 5);
// => Next: [5]

database.insertEvent('counter-events', 6);
// => Next: [6]

// The observable will continue listening for new events until it is unsubscribed.
```

You can query all available events in the form of a Promise:

```js
database.query('counter-events');

// insertEvents() inserts multiple events into the same key at once, and returns a
// promise that resolves when the events have been written to the datastore
database.insertEvents('counter-events', [1,2,3]).then(function() {
  return database.query('counter-events')
}).then(function(results) {
  console.log('Results: ' + results);
})

// Results: [1,2,3]
```

## Cursors

Observables from the EventStore can optionally include a cursor. A cursor allows you to a unsubscribe from an observable, and resubscribe later where you left off, possibly in a different process. This is useful if you need to resume an observable after a WebSocket disconnects, or you have a long running worker process to project an event stream onto another data structure.

```js
database.insertEvents('messages', ['Hello', 'World'])

// Specify `null` as a cursor to start from the beginning
var source = database.query('messages', {cursor: null});

const subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });

// Next: [{cursor: 2, value: ['hello', 'world']}]

// .. at some point in the future
database.insertEvents('messages', ['Foo', 'Bar']);

// Pass in the last cursor that was emitted by the first subscription
var source = database.query('messages', {cursor: 2});

const subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });
    
// Next: [{cursor: 4, value: ['foo', 'bar']}]

```

## Metadata

When an event is inserted into the store, you can include various metadata that describes when/where and who created the event. RxEventStore supports the following metadata fields:

 - `id` - An integer that is guaranteed to be unique for that particiular datastore.
 - `timestamp` - A Date object that describes when the event occured
 - `processId` - A uuid of the process that wrote the event into the datastore
 - `sessionId` - A uuid that uniquely identifies the browser session of the user that created the event.
 - `actor` - A JSON structure that identifies the user that created the event.
 - `aggregateRoot` - A string that be used to group events around a common root, such as a chat room, or blog post.

## Filtering

Observables can optionally filter by metadata.

```js
var source = database.query('comments', {
  filters: {aggregateRoot: 'blog-post-3'}
});
```

This could also be accomplished by using an RxJs filter operator. The advantage
of the previous method is that the filtering can happen in SQL.

```js
var source = database.query('comments', {includeMetadata: 'aggregateRoot'})
  .filter(e => e.aggregateRoot === 'blog-post-3')
```

You can also can more complicated filters. For example, you might want to only
receive the events created within the past hour.

```js
var source = database.query('pings', {
  timestamp: {$gt: new Date(Date.now() - 60 * 60 * 1000)}
});
```

## Notifications

TODO: Write me

## Projections

Sometimes, querying the event log is not the most efficient way to inquire about the state of your application. In these cases, it can make sense to project you event log onto another more appropriate data structure. These secondary data structures called "projections", and RxEventStore has a mechanism to help you maintain them.

Projections are generated and updated via the event log. They are considered denormalized views of your event log. Projections are updated by creating new events, and never by writing to the projections directly.

```js
TODO: Put a projection code sample here
```
